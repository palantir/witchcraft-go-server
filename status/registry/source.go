// Copyright (c) 2019 Palantir Technologies. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package registry

import (
	"context"
	"sort"
	"sync"
	"time"

	"github.com/palantir/witchcraft-go-server/conjure/witchcraft/api/health"
	"github.com/palantir/witchcraft-go-server/status"
)

// HealthCheckRegistry is a dynamic and thread safe collection of health checks indexed by string keys.
// It exposes all underlying health checks by using a CombinedHealthCheckSource.
// The combination of the provided health checks is done in the order they were registered.
// In other words, if multiple check types collide, the one that was generated by the latest registered health check source will be used.
// It is useful for adding extra health checks after a server has been initialized.
type HealthCheckRegistry interface {
	status.HealthCheckSource
	Register(key string, source status.HealthCheckSource)
	Unregister(key string)
}

type timedHealthCheckSource struct {
	timestamp time.Time
	source    status.HealthCheckSource
}

type healthCheckRegistry struct {
	mutex    sync.RWMutex
	registry map[string]timedHealthCheckSource
}

// NewHealthCheckRegistry creates a new HealthCheckRegistry.
func NewHealthCheckRegistry() HealthCheckRegistry {
	return &healthCheckRegistry{
		mutex:    sync.RWMutex{},
		registry: make(map[string]timedHealthCheckSource),
	}
}

func (h *healthCheckRegistry) HealthStatus(ctx context.Context) health.HealthStatus {
	h.mutex.RLock()
	defer h.mutex.RUnlock()

	timedSources := make([]timedHealthCheckSource, 0, len(h.registry))
	for _, timedSource := range h.registry {
		timedSources = append(timedSources, timedSource)
	}
	sort.SliceStable(timedSources, func(i, j int) bool {
		return timedSources[i].timestamp.Before(timedSources[j].timestamp)
	})
	sources := make([]status.HealthCheckSource, 0, len(timedSources))
	for _, timedSource := range timedSources {
		sources = append(sources, timedSource.source)
	}

	return status.NewCombinedHealthCheckSource(sources...).HealthStatus(ctx)
}

func (h *healthCheckRegistry) Register(key string, source status.HealthCheckSource) {
	h.mutex.Lock()
	defer h.mutex.Unlock()

	h.registry[key] = timedHealthCheckSource{
		timestamp: time.Now(),
		source:    source,
	}
}

func (h *healthCheckRegistry) Unregister(key string) {
	h.mutex.Lock()
	defer h.mutex.Unlock()

	delete(h.registry, key)
}
