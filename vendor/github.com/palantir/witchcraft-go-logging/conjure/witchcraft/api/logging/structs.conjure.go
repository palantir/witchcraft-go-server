// This file was generated by Conjure and should not be manually edited.

package logging

import (
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
)

// A Zipkin-compatible Annotation object.
type Annotation struct {
	// Time annotation was created (epoch microsecond value)
	Timestamp safelong.SafeLong `conjure-docs:"Time annotation was created (epoch microsecond value)" json:"timestamp"`
	// Value encapsulated by this annotation
	Value    string   `conjure-docs:"Value encapsulated by this annotation" json:"value"`
	Endpoint Endpoint `json:"endpoint"`
}

func (o Annotation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Annotation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the audit.2 format.
type AuditLogV2 struct {
	// "audit.2"
	Type string            `conjure-docs:"\"audit.2\"" json:"type"`
	Time datetime.DateTime `json:"time"`
	// User id (if available). This is the most downstream caller.
	Uid *UserId `conjure-docs:"User id (if available). This is the most downstream caller." json:"uid"`
	// Session id (if available)
	Sid *SessionId `conjure-docs:"Session id (if available)" json:"sid"`
	// API token id (if available)
	TokenId *TokenId `conjure-docs:"API token id (if available)" json:"tokenId"`
	// Zipkin trace id (if available)
	TraceId *TraceId `conjure-docs:"Zipkin trace id (if available)" json:"traceId"`
	// All users upstream of the user currently taking an action. The first element in this list is the uid of the most upstream caller. This list does not include the `uid`.
	OtherUids []UserId `conjure-docs:"All users upstream of the user currently taking an action. The first element in this list is the uid of the most upstream caller. This list does not include the \"uid\"." json:"otherUids"`
	/*
	   Best-effort identifier of the originating machine, e.g. an IP address, a Kubernetes node identifier,
	   or similar
	*/
	Origin *string `conjure-docs:"Best-effort identifier of the originating machine, e.g. an IP address, a Kubernetes node identifier,\nor similar" json:"origin"`
	// Name of the audit event, e.g. PUT_FILE
	Name string `conjure-docs:"Name of the audit event, e.g. PUT_FILE" json:"name"`
	// Indicates whether the request was successful or the type of failure, e.g. ERROR or UNAUTHORIZED
	Result AuditResult `conjure-docs:"Indicates whether the request was successful or the type of failure, e.g. ERROR or UNAUTHORIZED" json:"result"`
	// The parameters known at method invocation time.
	RequestParams map[string]interface{} `conjure-docs:"The parameters known at method invocation time." json:"requestParams"`
	// Information derived within a method, commonly parts of the return value.
	ResultParams map[string]interface{} `conjure-docs:"Information derived within a method, commonly parts of the return value." json:"resultParams"`
}

func (o AuditLogV2) MarshalJSON() ([]byte, error) {
	if o.OtherUids == nil {
		o.OtherUids = make([]UserId, 0)
	}
	if o.RequestParams == nil {
		o.RequestParams = make(map[string]interface{}, 0)
	}
	if o.ResultParams == nil {
		o.ResultParams = make(map[string]interface{}, 0)
	}
	type AuditLogV2Alias AuditLogV2
	return safejson.Marshal(AuditLogV2Alias(o))
}

func (o *AuditLogV2) UnmarshalJSON(data []byte) error {
	type AuditLogV2Alias AuditLogV2
	var rawAuditLogV2 AuditLogV2Alias
	if err := safejson.Unmarshal(data, &rawAuditLogV2); err != nil {
		return err
	}
	if rawAuditLogV2.OtherUids == nil {
		rawAuditLogV2.OtherUids = make([]UserId, 0)
	}
	if rawAuditLogV2.RequestParams == nil {
		rawAuditLogV2.RequestParams = make(map[string]interface{}, 0)
	}
	if rawAuditLogV2.ResultParams == nil {
		rawAuditLogV2.ResultParams = make(map[string]interface{}, 0)
	}
	*o = AuditLogV2(rawAuditLogV2)
	return nil
}

func (o AuditLogV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AuditLogV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the beacon.1 format.
type BeaconLogV1 struct {
	Type string            `json:"type"`
	Time datetime.DateTime `json:"time"`
	// Dot-delimited name for the structure of the params block, e.g. `compass.SearchEvent.v1`
	EventType string `conjure-docs:"Dot-delimited name for the structure of the params block, e.g. \"compass.SearchEvent.v1\"" json:"eventType"`
	// Name of the application that created the log
	AppName string `conjure-docs:"Name of the application that created the log" json:"appName"`
	// Version of the application that created the log
	AppVersion string `conjure-docs:"Version of the application that created the log" json:"appVersion"`
	// Known-safe parameters (redaction may be used to make params knowably safe, but is not required)
	Params map[string]interface{} `conjure-docs:"Known-safe parameters (redaction may be used to make params knowably safe, but is not required)" json:"params"`
	// Browser identifier (if available)
	BrowserId *string `conjure-docs:"Browser identifier (if available)" json:"browserId"`
	// User id (if available)
	Uid *UserId `conjure-docs:"User id (if available)" json:"uid"`
	// Session id (if available)
	Sid *SessionId `conjure-docs:"Session id (if available)" json:"sid"`
	// Zipkin trace id (if available)
	TraceId *TraceId `conjure-docs:"Zipkin trace id (if available)" json:"traceId"`
	// Unredacted parameters
	UnsafeParams map[string]interface{} `conjure-docs:"Unredacted parameters" json:"unsafeParams"`
}

func (o BeaconLogV1) MarshalJSON() ([]byte, error) {
	if o.Params == nil {
		o.Params = make(map[string]interface{}, 0)
	}
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	type BeaconLogV1Alias BeaconLogV1
	return safejson.Marshal(BeaconLogV1Alias(o))
}

func (o *BeaconLogV1) UnmarshalJSON(data []byte) error {
	type BeaconLogV1Alias BeaconLogV1
	var rawBeaconLogV1 BeaconLogV1Alias
	if err := safejson.Unmarshal(data, &rawBeaconLogV1); err != nil {
		return err
	}
	if rawBeaconLogV1.Params == nil {
		rawBeaconLogV1.Params = make(map[string]interface{}, 0)
	}
	if rawBeaconLogV1.UnsafeParams == nil {
		rawBeaconLogV1.UnsafeParams = make(map[string]interface{}, 0)
	}
	*o = BeaconLogV1(rawBeaconLogV1)
	return nil
}

func (o BeaconLogV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BeaconLogV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the diagnostic.1 format.
type DiagnosticLogV1 struct {
	// "diagnostic.1"
	Type string            `conjure-docs:"\"diagnostic.1\"" json:"type"`
	Time datetime.DateTime `json:"time"`
	// The diagnostic being logged.
	Diagnostic Diagnostic `conjure-docs:"The diagnostic being logged." json:"diagnostic"`
	// Unredacted parameters
	UnsafeParams map[string]interface{} `conjure-docs:"Unredacted parameters" json:"unsafeParams"`
}

func (o DiagnosticLogV1) MarshalJSON() ([]byte, error) {
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	type DiagnosticLogV1Alias DiagnosticLogV1
	return safejson.Marshal(DiagnosticLogV1Alias(o))
}

func (o *DiagnosticLogV1) UnmarshalJSON(data []byte) error {
	type DiagnosticLogV1Alias DiagnosticLogV1
	var rawDiagnosticLogV1 DiagnosticLogV1Alias
	if err := safejson.Unmarshal(data, &rawDiagnosticLogV1); err != nil {
		return err
	}
	if rawDiagnosticLogV1.UnsafeParams == nil {
		rawDiagnosticLogV1.UnsafeParams = make(map[string]interface{}, 0)
	}
	*o = DiagnosticLogV1(rawDiagnosticLogV1)
	return nil
}

func (o DiagnosticLogV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DiagnosticLogV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Endpoint struct {
	// Name of the service that generated the annotation
	ServiceName string `conjure-docs:"Name of the service that generated the annotation" json:"serviceName"`
	// IPv4 address of the machine that generated this annotation (`xxx.xxx.xxx.xxx`)
	Ipv4 *string `conjure-docs:"IPv4 address of the machine that generated this annotation (\"xxx.xxx.xxx.xxx\")" json:"ipv4"`
	// IPv6 address of the machine that generated this annotation (standard hextet form)
	Ipv6 *string `conjure-docs:"IPv6 address of the machine that generated this annotation (standard hextet form)" json:"ipv6"`
}

func (o Endpoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Endpoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the event.1 format.
type EventLogV1 struct {
	Type string            `json:"type"`
	Time datetime.DateTime `json:"time"`
	// Dot-delimited name of event, e.g. `com.foundry.compass.api.Compass.http.ping.failures`
	EventName string `conjure-docs:"Dot-delimited name of event, e.g. \"com.foundry.compass.api.Compass.http.ping.failures\"" json:"eventName"`
	// Type of event being represented, e.g. `gauge`, `histogram`, `counter`
	EventType string `conjure-docs:"Type of event being represented, e.g. \"gauge\", \"histogram\", \"counter\"" json:"eventType"`
	// Observations, measurements and context associated with the event
	Values map[string]interface{} `conjure-docs:"Observations, measurements and context associated with the event" json:"values"`
	// User id (if available)
	Uid *UserId `conjure-docs:"User id (if available)" json:"uid"`
	// Session id (if available)
	Sid *SessionId `conjure-docs:"Session id (if available)" json:"sid"`
	// API token id (if available)
	TokenId *TokenId `conjure-docs:"API token id (if available)" json:"tokenId"`
	// Unsafe metadata describing the event
	UnsafeParams map[string]interface{} `conjure-docs:"Unsafe metadata describing the event" json:"unsafeParams"`
}

func (o EventLogV1) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make(map[string]interface{}, 0)
	}
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	type EventLogV1Alias EventLogV1
	return safejson.Marshal(EventLogV1Alias(o))
}

func (o *EventLogV1) UnmarshalJSON(data []byte) error {
	type EventLogV1Alias EventLogV1
	var rawEventLogV1 EventLogV1Alias
	if err := safejson.Unmarshal(data, &rawEventLogV1); err != nil {
		return err
	}
	if rawEventLogV1.Values == nil {
		rawEventLogV1.Values = make(map[string]interface{}, 0)
	}
	if rawEventLogV1.UnsafeParams == nil {
		rawEventLogV1.UnsafeParams = make(map[string]interface{}, 0)
	}
	*o = EventLogV1(rawEventLogV1)
	return nil
}

func (o EventLogV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EventLogV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the event.2 format.
type EventLogV2 struct {
	Type string            `json:"type"`
	Time datetime.DateTime `json:"time"`
	// Dot-delimited name of event, e.g. `com.foundry.compass.api.Compass.http.ping.failures`
	EventName string `conjure-docs:"Dot-delimited name of event, e.g. \"com.foundry.compass.api.Compass.http.ping.failures\"" json:"eventName"`
	// Observations, measurements and context associated with the event
	Values map[string]interface{} `conjure-docs:"Observations, measurements and context associated with the event" json:"values"`
	// User id (if available)
	Uid *UserId `conjure-docs:"User id (if available)" json:"uid"`
	// Session id (if available)
	Sid *SessionId `conjure-docs:"Session id (if available)" json:"sid"`
	// API token id (if available)
	TokenId *TokenId `conjure-docs:"API token id (if available)" json:"tokenId"`
	// Zipkin trace id (if available)
	TraceId *TraceId `conjure-docs:"Zipkin trace id (if available)" json:"traceId"`
	// Unsafe metadata describing the event
	UnsafeParams map[string]interface{} `conjure-docs:"Unsafe metadata describing the event" json:"unsafeParams"`
	// Additional dimensions that describe the instance of the log event
	Tags map[string]string `conjure-docs:"Additional dimensions that describe the instance of the log event" json:"tags"`
}

func (o EventLogV2) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make(map[string]interface{}, 0)
	}
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	if o.Tags == nil {
		o.Tags = make(map[string]string, 0)
	}
	type EventLogV2Alias EventLogV2
	return safejson.Marshal(EventLogV2Alias(o))
}

func (o *EventLogV2) UnmarshalJSON(data []byte) error {
	type EventLogV2Alias EventLogV2
	var rawEventLogV2 EventLogV2Alias
	if err := safejson.Unmarshal(data, &rawEventLogV2); err != nil {
		return err
	}
	if rawEventLogV2.Values == nil {
		rawEventLogV2.Values = make(map[string]interface{}, 0)
	}
	if rawEventLogV2.UnsafeParams == nil {
		rawEventLogV2.UnsafeParams = make(map[string]interface{}, 0)
	}
	if rawEventLogV2.Tags == nil {
		rawEventLogV2.Tags = make(map[string]string, 0)
	}
	*o = EventLogV2(rawEventLogV2)
	return nil
}

func (o EventLogV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EventLogV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GenericDiagnostic struct {
	// An identifier for the type of diagnostic represented.
	DiagnosticType string `conjure-docs:"An identifier for the type of diagnostic represented." json:"diagnosticType"`
	// Observations, measurements and context associated with the diagnostic.
	Value interface{} `conjure-docs:"Observations, measurements and context associated with the diagnostic." json:"value"`
}

func (o GenericDiagnostic) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GenericDiagnostic) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the metric.1 format.
type MetricLogV1 struct {
	Type string            `json:"type"`
	Time datetime.DateTime `json:"time"`
	// Dot-delimited name of metric, e.g. `com.foundry.compass.api.Compass.http.ping.failures`
	MetricName string `conjure-docs:"Dot-delimited name of metric, e.g. \"com.foundry.compass.api.Compass.http.ping.failures\"" json:"metricName"`
	// Type of metric being represented, e.g. `gauge`, `histogram`, `counter`
	MetricType string `conjure-docs:"Type of metric being represented, e.g. \"gauge\", \"histogram\", \"counter\"" json:"metricType"`
	// Observations, measurements and context associated with the metric
	Values map[string]interface{} `conjure-docs:"Observations, measurements and context associated with the metric" json:"values"`
	// Additional dimensions that describe the instance of the metric
	Tags map[string]string `conjure-docs:"Additional dimensions that describe the instance of the metric" json:"tags"`
	// User id (if available)
	Uid *UserId `conjure-docs:"User id (if available)" json:"uid"`
	// Session id (if available)
	Sid *SessionId `conjure-docs:"Session id (if available)" json:"sid"`
	// API token id (if available)
	TokenId *TokenId `conjure-docs:"API token id (if available)" json:"tokenId"`
	// Unsafe metadata describing the event
	UnsafeParams map[string]interface{} `conjure-docs:"Unsafe metadata describing the event" json:"unsafeParams"`
}

func (o MetricLogV1) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make(map[string]interface{}, 0)
	}
	if o.Tags == nil {
		o.Tags = make(map[string]string, 0)
	}
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	type MetricLogV1Alias MetricLogV1
	return safejson.Marshal(MetricLogV1Alias(o))
}

func (o *MetricLogV1) UnmarshalJSON(data []byte) error {
	type MetricLogV1Alias MetricLogV1
	var rawMetricLogV1 MetricLogV1Alias
	if err := safejson.Unmarshal(data, &rawMetricLogV1); err != nil {
		return err
	}
	if rawMetricLogV1.Values == nil {
		rawMetricLogV1.Values = make(map[string]interface{}, 0)
	}
	if rawMetricLogV1.Tags == nil {
		rawMetricLogV1.Tags = make(map[string]string, 0)
	}
	if rawMetricLogV1.UnsafeParams == nil {
		rawMetricLogV1.UnsafeParams = make(map[string]interface{}, 0)
	}
	*o = MetricLogV1(rawMetricLogV1)
	return nil
}

func (o MetricLogV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MetricLogV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the request.1 format.
type RequestLogV1 struct {
	Type string            `json:"type"`
	Time datetime.DateTime `json:"time"`
	// HTTP method of request
	Method *string `conjure-docs:"HTTP method of request" json:"method"`
	// Protocol, e.g. `HTTP/1.1`, `HTTP/2`
	Protocol string `conjure-docs:"Protocol, e.g. \"HTTP/1.1\", \"HTTP/2\"" json:"protocol"`
	// Path of request. If templated, the unrendered path, e.g.: `/catalog/dataset/{datasetId}`, `/{rid}/paths/contents/{path:.*}`.
	Path string `conjure-docs:"Path of request. If templated, the unrendered path, e.g.: \"/catalog/dataset/{datasetId}\", \"/{rid}/paths/contents/{path:.*}\"." json:"path"`
	// Known-safe path parameters
	PathParams map[string]interface{} `conjure-docs:"Known-safe path parameters" json:"pathParams"`
	// Known-safe query parameters
	QueryParams map[string]interface{} `conjure-docs:"Known-safe query parameters" json:"queryParams"`
	// Known-safe header parameters
	HeaderParams map[string]interface{} `conjure-docs:"Known-safe header parameters" json:"headerParams"`
	// Known-safe body parameters
	BodyParams map[string]interface{} `conjure-docs:"Known-safe body parameters" json:"bodyParams"`
	// HTTP status code of response
	Status int `conjure-docs:"HTTP status code of response" json:"status"`
	// Size of request (bytes). string to allow large numbers.
	RequestSize string `conjure-docs:"Size of request (bytes). string to allow large numbers." json:"requestSize"`
	// Size of response (bytes). string to allow large numbers.
	ResponseSize string `conjure-docs:"Size of response (bytes). string to allow large numbers." json:"responseSize"`
	// Amount of time spent handling request (microseconds)
	Duration int `conjure-docs:"Amount of time spent handling request (microseconds)" json:"duration"`
	// User id (if available)
	Uid *UserId `conjure-docs:"User id (if available)" json:"uid"`
	// Session id (if available)
	Sid *SessionId `conjure-docs:"Session id (if available)" json:"sid"`
	// API token id (if available)
	TokenId *TokenId `conjure-docs:"API token id (if available)" json:"tokenId"`
	// Zipkin trace id (if available)
	TraceId *TraceId `conjure-docs:"Zipkin trace id (if available)" json:"traceId"`
	// Unredacted parameters such as path, query and header parameters
	UnsafeParams map[string]interface{} `conjure-docs:"Unredacted parameters such as path, query and header parameters" json:"unsafeParams"`
}

func (o RequestLogV1) MarshalJSON() ([]byte, error) {
	if o.PathParams == nil {
		o.PathParams = make(map[string]interface{}, 0)
	}
	if o.QueryParams == nil {
		o.QueryParams = make(map[string]interface{}, 0)
	}
	if o.HeaderParams == nil {
		o.HeaderParams = make(map[string]interface{}, 0)
	}
	if o.BodyParams == nil {
		o.BodyParams = make(map[string]interface{}, 0)
	}
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	type RequestLogV1Alias RequestLogV1
	return safejson.Marshal(RequestLogV1Alias(o))
}

func (o *RequestLogV1) UnmarshalJSON(data []byte) error {
	type RequestLogV1Alias RequestLogV1
	var rawRequestLogV1 RequestLogV1Alias
	if err := safejson.Unmarshal(data, &rawRequestLogV1); err != nil {
		return err
	}
	if rawRequestLogV1.PathParams == nil {
		rawRequestLogV1.PathParams = make(map[string]interface{}, 0)
	}
	if rawRequestLogV1.QueryParams == nil {
		rawRequestLogV1.QueryParams = make(map[string]interface{}, 0)
	}
	if rawRequestLogV1.HeaderParams == nil {
		rawRequestLogV1.HeaderParams = make(map[string]interface{}, 0)
	}
	if rawRequestLogV1.BodyParams == nil {
		rawRequestLogV1.BodyParams = make(map[string]interface{}, 0)
	}
	if rawRequestLogV1.UnsafeParams == nil {
		rawRequestLogV1.UnsafeParams = make(map[string]interface{}, 0)
	}
	*o = RequestLogV1(rawRequestLogV1)
	return nil
}

func (o RequestLogV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RequestLogV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the request.2 format.
type RequestLogV2 struct {
	Type string            `json:"type"`
	Time datetime.DateTime `json:"time"`
	// HTTP method of request
	Method *string `conjure-docs:"HTTP method of request" json:"method"`
	// Protocol, e.g. `HTTP/1.1`, `HTTP/2`
	Protocol string `conjure-docs:"Protocol, e.g. \"HTTP/1.1\", \"HTTP/2\"" json:"protocol"`
	// Path of request. If templated, the unrendered path, e.g.: `/catalog/dataset/{datasetId}`, `/{rid}/paths/contents/{path:.*}`.
	Path string `conjure-docs:"Path of request. If templated, the unrendered path, e.g.: \"/catalog/dataset/{datasetId}\", \"/{rid}/paths/contents/{path:.*}\"." json:"path"`
	// Known-safe parameters
	Params map[string]interface{} `conjure-docs:"Known-safe parameters" json:"params"`
	// HTTP status code of response
	Status int `conjure-docs:"HTTP status code of response" json:"status"`
	// Size of request (bytes)
	RequestSize safelong.SafeLong `conjure-docs:"Size of request (bytes)" json:"requestSize"`
	// Size of response (bytes)
	ResponseSize safelong.SafeLong `conjure-docs:"Size of response (bytes)" json:"responseSize"`
	// Amount of time spent handling request (microseconds)
	Duration safelong.SafeLong `conjure-docs:"Amount of time spent handling request (microseconds)" json:"duration"`
	// User id (if available)
	Uid *UserId `conjure-docs:"User id (if available)" json:"uid"`
	// Session id (if available)
	Sid *SessionId `conjure-docs:"Session id (if available)" json:"sid"`
	// API token id (if available)
	TokenId *TokenId `conjure-docs:"API token id (if available)" json:"tokenId"`
	// Zipkin trace id (if available)
	TraceId *TraceId `conjure-docs:"Zipkin trace id (if available)" json:"traceId"`
	// Unredacted parameters such as path, query and header parameters
	UnsafeParams map[string]interface{} `conjure-docs:"Unredacted parameters such as path, query and header parameters" json:"unsafeParams"`
}

func (o RequestLogV2) MarshalJSON() ([]byte, error) {
	if o.Params == nil {
		o.Params = make(map[string]interface{}, 0)
	}
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	type RequestLogV2Alias RequestLogV2
	return safejson.Marshal(RequestLogV2Alias(o))
}

func (o *RequestLogV2) UnmarshalJSON(data []byte) error {
	type RequestLogV2Alias RequestLogV2
	var rawRequestLogV2 RequestLogV2Alias
	if err := safejson.Unmarshal(data, &rawRequestLogV2); err != nil {
		return err
	}
	if rawRequestLogV2.Params == nil {
		rawRequestLogV2.Params = make(map[string]interface{}, 0)
	}
	if rawRequestLogV2.UnsafeParams == nil {
		rawRequestLogV2.UnsafeParams = make(map[string]interface{}, 0)
	}
	*o = RequestLogV2(rawRequestLogV2)
	return nil
}

func (o RequestLogV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RequestLogV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the service.1 format.
type ServiceLogV1 struct {
	// "service.1"
	Type string `conjure-docs:"\"service.1\"" json:"type"`
	// The logger output level. One of {FATAL,ERROR,WARN,INFO,DEBUG,TRACE}.
	Level LogLevel `conjure-docs:"The logger output level. One of {FATAL,ERROR,WARN,INFO,DEBUG,TRACE}." json:"level"`
	// RFC3339Nano UTC datetime string when the log event was emitted
	Time datetime.DateTime `conjure-docs:"RFC3339Nano UTC datetime string when the log event was emitted" json:"time"`
	// Class or file name. May include line number.
	Origin *string `conjure-docs:"Class or file name. May include line number." json:"origin"`
	// Thread name
	Thread *string `conjure-docs:"Thread name" json:"thread"`
	// Log message. Palantir Java services using slf4j should not use slf4j placeholders ({}). Logs obtained from 3rd party libraries or services that use slf4j and contain slf4j placeholders will always produce `unsafeParams` with numeric indexes corresponding to the zero-indexed order of placeholders. Renderers should substitute numeric parameters from `unsafeParams` and may leave placeholders that do not match indexes as the original placeholder text.
	Message string `conjure-docs:"Log message. Palantir Java services using slf4j should not use slf4j placeholders ({}). Logs obtained from 3rd party libraries or services that use slf4j and contain slf4j placeholders will always produce \"unsafeParams\" with numeric indexes corresponding to the zero-indexed order of placeholders. Renderers should substitute numeric parameters from \"unsafeParams\" and may leave placeholders that do not match indexes as the original placeholder text." json:"message"`
	// Known-safe parameters (redaction may be used to make params knowably safe, but is not required).
	Params map[string]interface{} `conjure-docs:"Known-safe parameters (redaction may be used to make params knowably safe, but is not required)." json:"params"`
	// User id (if available).
	Uid *UserId `conjure-docs:"User id (if available)." json:"uid"`
	// Session id (if available)
	Sid *SessionId `conjure-docs:"Session id (if available)" json:"sid"`
	// API token id (if available)
	TokenId *TokenId `conjure-docs:"API token id (if available)" json:"tokenId"`
	// Zipkin trace id (if available)
	TraceId *TraceId `conjure-docs:"Zipkin trace id (if available)" json:"traceId"`
	// Language-specific stack trace. Content is knowably safe. Renderers should substitute named placeholders ({name}, for name as a key) with keyed value from unsafeParams and leave non-matching keys as the original placeholder text.
	Stacktrace *string `conjure-docs:"Language-specific stack trace. Content is knowably safe. Renderers should substitute named placeholders ({name}, for name as a key) with keyed value from unsafeParams and leave non-matching keys as the original placeholder text." json:"stacktrace"`
	// Unredacted parameters
	UnsafeParams map[string]interface{} `conjure-docs:"Unredacted parameters" json:"unsafeParams"`
	// Additional dimensions that describe the instance of the log event
	Tags map[string]string `conjure-docs:"Additional dimensions that describe the instance of the log event" json:"tags"`
}

func (o ServiceLogV1) MarshalJSON() ([]byte, error) {
	if o.Params == nil {
		o.Params = make(map[string]interface{}, 0)
	}
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	if o.Tags == nil {
		o.Tags = make(map[string]string, 0)
	}
	type ServiceLogV1Alias ServiceLogV1
	return safejson.Marshal(ServiceLogV1Alias(o))
}

func (o *ServiceLogV1) UnmarshalJSON(data []byte) error {
	type ServiceLogV1Alias ServiceLogV1
	var rawServiceLogV1 ServiceLogV1Alias
	if err := safejson.Unmarshal(data, &rawServiceLogV1); err != nil {
		return err
	}
	if rawServiceLogV1.Params == nil {
		rawServiceLogV1.Params = make(map[string]interface{}, 0)
	}
	if rawServiceLogV1.UnsafeParams == nil {
		rawServiceLogV1.UnsafeParams = make(map[string]interface{}, 0)
	}
	if rawServiceLogV1.Tags == nil {
		rawServiceLogV1.Tags = make(map[string]string, 0)
	}
	*o = ServiceLogV1(rawServiceLogV1)
	return nil
}

func (o ServiceLogV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ServiceLogV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A Zipkin-compatible Span object.
type Span struct {
	// 16-digit hex trace identifier
	TraceId string `conjure-docs:"16-digit hex trace identifier" json:"traceId"`
	// 16-digit hex span identifier
	Id string `conjure-docs:"16-digit hex span identifier" json:"id"`
	// Name of the span (typically the operation/RPC/method name for corresponding to this span)
	Name string `conjure-docs:"Name of the span (typically the operation/RPC/method name for corresponding to this span)" json:"name"`
	// 16-digit hex identifer of the parent span
	ParentId *string `conjure-docs:"16-digit hex identifer of the parent span" json:"parentId"`
	// Timestamp of the start of this span (epoch microsecond value)
	Timestamp safelong.SafeLong `conjure-docs:"Timestamp of the start of this span (epoch microsecond value)" json:"timestamp"`
	// Duration of this span (microseconds)
	Duration    safelong.SafeLong `conjure-docs:"Duration of this span (microseconds)" json:"duration"`
	Annotations []Annotation      `json:"annotations"`
	// Additional dimensions that describe the instance of the trace span
	Tags map[string]string `conjure-docs:"Additional dimensions that describe the instance of the trace span" json:"tags"`
}

func (o Span) MarshalJSON() ([]byte, error) {
	if o.Annotations == nil {
		o.Annotations = make([]Annotation, 0)
	}
	if o.Tags == nil {
		o.Tags = make(map[string]string, 0)
	}
	type SpanAlias Span
	return safejson.Marshal(SpanAlias(o))
}

func (o *Span) UnmarshalJSON(data []byte) error {
	type SpanAlias Span
	var rawSpan SpanAlias
	if err := safejson.Unmarshal(data, &rawSpan); err != nil {
		return err
	}
	if rawSpan.Annotations == nil {
		rawSpan.Annotations = make([]Annotation, 0)
	}
	if rawSpan.Tags == nil {
		rawSpan.Tags = make(map[string]string, 0)
	}
	*o = Span(rawSpan)
	return nil
}

func (o Span) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Span) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type StackFrameV1 struct {
	// The address of the execution point of this stack frame. This is a string because a safelong can't represent the full 64 bit address space.
	Address *string `conjure-docs:"The address of the execution point of this stack frame. This is a string because a safelong can't represent the full 64 bit address space." json:"address"`
	// The identifier of the procedure containing the execution point of this stack frame. This is a fully qualified method name in Java and a demangled symbol name in native code, for example. Note that procedure names may include unsafe information if a service is, for exmaple, running user-defined code. It must be safely redacted.
	Procedure *string `conjure-docs:"The identifier of the procedure containing the execution point of this stack frame. This is a fully qualified method name in Java and a demangled symbol name in native code, for example. Note that procedure names may include unsafe information if a service is, for exmaple, running user-defined code. It must be safely redacted." json:"procedure"`
	// The name of the file containing the source location of the execution point of this stack frame. Note that file names may include unsafe information if a service is, for example, running user-defined code. It must be safely redacted.
	File *string `conjure-docs:"The name of the file containing the source location of the execution point of this stack frame. Note that file names may include unsafe information if a service is, for example, running user-defined code. It must be safely redacted." json:"file"`
	// The line number of the source location of the execution point of this stack frame.
	Line *int `conjure-docs:"The line number of the source location of the execution point of this stack frame." json:"line"`
	// Other frame-level information.
	Params map[string]interface{} `conjure-docs:"Other frame-level information." json:"params"`
}

func (o StackFrameV1) MarshalJSON() ([]byte, error) {
	if o.Params == nil {
		o.Params = make(map[string]interface{}, 0)
	}
	type StackFrameV1Alias StackFrameV1
	return safejson.Marshal(StackFrameV1Alias(o))
}

func (o *StackFrameV1) UnmarshalJSON(data []byte) error {
	type StackFrameV1Alias StackFrameV1
	var rawStackFrameV1 StackFrameV1Alias
	if err := safejson.Unmarshal(data, &rawStackFrameV1); err != nil {
		return err
	}
	if rawStackFrameV1.Params == nil {
		rawStackFrameV1.Params = make(map[string]interface{}, 0)
	}
	*o = StackFrameV1(rawStackFrameV1)
	return nil
}

func (o StackFrameV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StackFrameV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ThreadDumpV1 struct {
	// Information about each of the threads in the thread dump. "Thread" may refer to a userland thread such as a goroutine, or an OS-level thread.
	Threads []ThreadInfoV1 `conjure-docs:"Information about each of the threads in the thread dump. \"Thread\" may refer to a userland thread such as a goroutine, or an OS-level thread." json:"threads"`
}

func (o ThreadDumpV1) MarshalJSON() ([]byte, error) {
	if o.Threads == nil {
		o.Threads = make([]ThreadInfoV1, 0)
	}
	type ThreadDumpV1Alias ThreadDumpV1
	return safejson.Marshal(ThreadDumpV1Alias(o))
}

func (o *ThreadDumpV1) UnmarshalJSON(data []byte) error {
	type ThreadDumpV1Alias ThreadDumpV1
	var rawThreadDumpV1 ThreadDumpV1Alias
	if err := safejson.Unmarshal(data, &rawThreadDumpV1); err != nil {
		return err
	}
	if rawThreadDumpV1.Threads == nil {
		rawThreadDumpV1.Threads = make([]ThreadInfoV1, 0)
	}
	*o = ThreadDumpV1(rawThreadDumpV1)
	return nil
}

func (o ThreadDumpV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ThreadDumpV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ThreadInfoV1 struct {
	// The ID of the thread.
	Id *safelong.SafeLong `conjure-docs:"The ID of the thread." json:"id"`
	// The name of the thread. Note that thread names may include unsafe information such as the path of the HTTP request being processed. It must be safely redacted.
	Name *string `conjure-docs:"The name of the thread. Note that thread names may include unsafe information such as the path of the HTTP request being processed. It must be safely redacted." json:"name"`
	// A list of stack frames for the thread, ordered with the current frame first.
	StackTrace []StackFrameV1 `conjure-docs:"A list of stack frames for the thread, ordered with the current frame first." json:"stackTrace"`
	// Other thread-level information.
	Params map[string]interface{} `conjure-docs:"Other thread-level information." json:"params"`
}

func (o ThreadInfoV1) MarshalJSON() ([]byte, error) {
	if o.StackTrace == nil {
		o.StackTrace = make([]StackFrameV1, 0)
	}
	if o.Params == nil {
		o.Params = make(map[string]interface{}, 0)
	}
	type ThreadInfoV1Alias ThreadInfoV1
	return safejson.Marshal(ThreadInfoV1Alias(o))
}

func (o *ThreadInfoV1) UnmarshalJSON(data []byte) error {
	type ThreadInfoV1Alias ThreadInfoV1
	var rawThreadInfoV1 ThreadInfoV1Alias
	if err := safejson.Unmarshal(data, &rawThreadInfoV1); err != nil {
		return err
	}
	if rawThreadInfoV1.StackTrace == nil {
		rawThreadInfoV1.StackTrace = make([]StackFrameV1, 0)
	}
	if rawThreadInfoV1.Params == nil {
		rawThreadInfoV1.Params = make(map[string]interface{}, 0)
	}
	*o = ThreadInfoV1(rawThreadInfoV1)
	return nil
}

func (o ThreadInfoV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ThreadInfoV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Definition of the trace.1 format.
type TraceLogV1 struct {
	Type         string                 `json:"type"`
	Time         datetime.DateTime      `json:"time"`
	Uid          *UserId                `json:"uid"`
	Sid          *SessionId             `json:"sid"`
	TokenId      *TokenId               `json:"tokenId"`
	UnsafeParams map[string]interface{} `json:"unsafeParams"`
	Span         Span                   `json:"span"`
}

func (o TraceLogV1) MarshalJSON() ([]byte, error) {
	if o.UnsafeParams == nil {
		o.UnsafeParams = make(map[string]interface{}, 0)
	}
	type TraceLogV1Alias TraceLogV1
	return safejson.Marshal(TraceLogV1Alias(o))
}

func (o *TraceLogV1) UnmarshalJSON(data []byte) error {
	type TraceLogV1Alias TraceLogV1
	var rawTraceLogV1 TraceLogV1Alias
	if err := safejson.Unmarshal(data, &rawTraceLogV1); err != nil {
		return err
	}
	if rawTraceLogV1.UnsafeParams == nil {
		rawTraceLogV1.UnsafeParams = make(map[string]interface{}, 0)
	}
	*o = TraceLogV1(rawTraceLogV1)
	return nil
}

func (o TraceLogV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TraceLogV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Wraps a log entry with entity information.
type WrappedLogV1 struct {
	// "wrapped.1"
	Type    string              `conjure-docs:"\"wrapped.1\"" json:"type"`
	Payload WrappedLogV1Payload `json:"payload"`
	// Artifact part of entity's maven coordinate
	EntityName    string `conjure-docs:"Artifact part of entity's maven coordinate" json:"entityName"`
	EntityVersion string `json:"entityVersion"`
}

func (o WrappedLogV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *WrappedLogV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
